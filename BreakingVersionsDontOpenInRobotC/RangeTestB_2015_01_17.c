#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     bottomLimitSwitch, sensorTouch)
#pragma config(Sensor, S3,     topLimitSwitch, sensorTouch)
#pragma config(Sensor, S4,     IrSeeker,       sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  motorA,          IrScanner,     tmotorNXT, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     left,          tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     right,         tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     lift,          tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     nada,          tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    TubeGrab,             tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    ScoopGate,            tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c";
//#include "MoveSingleTiming.c";
#include "DriveSingleencoder.c";

task main()
{

    char    buffer[16];

    nMotorEncoder[motorA] = 0;
    waitForStart();
    straight(70,12);
    while (true)
    {
       /* motor[motorA] = 0;
        while (SensorValue[IrSeeker] == 0)
        {
            nxtDisplayBigTextLine(3, "No IR" );
        }

        while (SensorValue[IrSeeker] < 5)
        {

            motor[motorA] = -40;
            nxtDisplayBigTextLine(3, "course up" );
             if(SensorValue[IrSeeker] == 0)
            {
               nxtDisplayBigTextLine(3, "zeroed" );
               break;
            }

        }
        motor[motorA] = 0;

        while (SensorValue[IrSeeker] > 5)
        {

            motor[motorA] = 40;
             nxtDisplayBigTextLine(3, "course down" );

              if(SensorValue[IrSeeker] == 0)
            {
               nxtDisplayBigTextLine(3, "zeroed" );
               break;
            }
        }
        motor[motorA] = 0;

       // Should be in zone 5 now
        motor[motorA] = -40;
        while (SensorValue[IrSeeker] == 5)
        {
            nxtDisplayBigTextLine(3, "fine up" );
            if(SensorValue[IrSeeker] == 0)
            {
               nxtDisplayBigTextLine(3, "zeroed" );
               break;
            }
            //move util IrSeeker finds the first threshold
        }
         motor[motorA] = 0;

         long leftSide = nMotorEncoder[motorA];

        motor[motorA] = 40;
       while (SensorValue[IrSeeker] != 5)
       {
            nxtDisplayBigTextLine(3, "fine down" );
            if(SensorValue[IrSeeker] == 0)
            {
               nxtDisplayBigTextLine(3, "zeroed" );
               break;
            }
           //move until IrSeeker sensing a value of 5 again
       }

        while(SensorValue[IrSeeker] == 5)
        {
            nxtDisplayBigTextLine(3, "fine down" );
             if(SensorValue[IrSeeker] == 0)
            {
               nxtDisplayBigTextLine(3, "zeroed" );
               break;
            }
            //move until IrSeeker find second threshold
   	    }
        motor[motorA] = 0;

        long rightSide = nMotorEncoder[motorA];

        float orientation = 0.6 * (leftSide + rightSide) / 2.0;

	    sprintf(buffer, "%d", leftSide);
        nxtDisplayBigTextLine(1 , buffer );
	    sprintf(buffer, "%d", rightSide);
        nxtDisplayBigTextLine(3 , buffer );*/
	    sprintf(buffer, "%f", SensorValue[IRSeeker]);
        nxtDisplayBigTextLine(5 , buffer );
    }
}
